<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="true"><meta name="msvalidate.01" content="true"><meta name="baidu-site-verification" content="true"><link rel="alternate" type="application/rss+xml" title="forget-me-not" href="https://maikire.xyz/rss.xml"><link rel="alternate" type="application/atom+xml" title="forget-me-not" href="https://maikire.xyz/atom.xml"><link rel="alternate" type="application/json" title="forget-me-not" href="https://maikire.xyz/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="CPP"><link rel="canonical" href="https://maikire.xyz/2025/11/11/CPP/CPPBasics/CPP%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><title>CPP 基础笔记 - CPPBasics - CPP | Starry Letter = forget-me-not</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CPP 基础笔记</h1><div class="meta"><span class="item" title="创建时间：2025-11-11 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-11-11T12:00:00+08:00">2025-11-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Starry Letter</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.z4a.net/images/2025/07/31/82332.jpeg"></li><li class="item" data-background-image="https://img.z4a.net/images/2025/07/31/88b39e07ea05c813c7918412dc6686ad8506bf8e_raw.jpeg"></li><li class="item" data-background-image="https://img.z4a.net/images/2025/07/31/63.jpeg"></li><li class="item" data-background-image="https://img.z4a.net/images/2025/08/01/sdf54516.jpeg"></li><li class="item" data-background-image="https://img.z4a.net/images/2025/08/01/sama.jpeg"></li><li class="item" data-background-image="https://img.z4a.net/images/2025/07/31/53d5091399b21c01f9d7127d5b928b3.jpeg"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CPP/" itemprop="item" rel="index" title="分类于 CPP"><span itemprop="name">CPP</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CPP/CPPBasics/" itemprop="item" rel="index" title="分类于 CPPBasics"><span itemprop="name">CPPBasics</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://maikire.xyz/2025/11/11/CPP/CPPBasics/CPP%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Maikire"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="forget-me-not"></span><div class="body md" itemprop="articleBody"><h1 id="基础一"><a class="anchor" href="#基础一">#</a> 基础一</h1><ul><li><code>#include&lt;iostream&gt;</code> C++ 的头文件，包含了程序必须的相关信息</li><li><code>main()</code> 的完整写法 <code>main(int argc, const char* argv[])</code></li><li><code>using namespace std;</code> 使用标准命名空间</li><li><code>endl</code> 英语意思是 <code>end of line</code> 一行输出结束，然后输出下一行。它的作用相当于在末尾添加换行符 \n</li><li>指数 <code>13e+8</code> 表示： <code>13*10^8</code><br>16 进制 <code>0xN</code> (N 为任意数)<br>2 进制 <code>0bN</code> (N 为任意数)<br>8 进制 <code>0N</code> (N 为任意数)</li><li>float 型数值后应加 f<br>float 有 7 位有效数字，注意：3.14 是 3 位有效数字</li><li>只有在类中的函数才需要声明访问级别</li><li>左值（lvalue）<br>有名字，有内存位置，可以出现在赋值号 = 的左边，在表达式结束后依然存在<br>例如： <code>int a = 10; // a 是左值</code></li><li>右值（rvalue）<br>没有名字，不能取地址，一般只能出现在 = 的右边，生命周期只在当前语句<br>右值能绑定到 <code>const T&amp;</code><br>例如： <code>int x = 10; // 10 是右值</code></li></ul><h2 id="指针"><a class="anchor" href="#指针">#</a> 指针</h2><ul><li>格式 <code>int a = 1; int* p; int* p = &amp;a;</code><br>指针（地址）前加 * 代表解引用，找到指针（地址）指向内存中的数据<br>p 与 &amp;a 同意，输出结果是 a 的地址<br>* p 与 *&amp;a 同意，输出结果为 1</li><li>不论什么数据类型，指针在 32 位系统中占用 4 字节，64 位系统中占用 8 字节</li><li>空指针（使用 nullptr 而不是 NULL）<br>在 C++ 中，NULL 其实就是一个整数常量 0，而不是一个独立的 “空指针类型”。<br>当存在函数重载时，NULL 容易引起二义性，形参是指针还是整数，编译器无法判断。<br>nullptr 是一个可以隐式转换为任意指针类型的特殊类型<br>0 - 255 之间的内存编号是系统占用的，因此不可访问（nullptr 对应的的编号是 0）<br>空指针和野指针都不是我们申请的空间，因此不要访问</li><li>const 与 指针<ul><li>const 修饰指针：常量指针<br><code>const int* p = &amp;a;</code><br>指针的指向可以修改，但指针指向的值不可修改（不可通过 *p 修改指针指向的常量）</li><li>const 修饰常量：指针常量<br><code>int* const p = &amp;a;</code><br>指针的指向不可修改，但指针指向的值可以修改（不可通过 *p 修改指针的指向）</li><li>const 即修饰指针，又修饰常量</li><li>口诀<br>const 在 * 左边：指向的值不能改<br>const 在 * 右边：指针本身不能改<br>左右都有：都不能改</li></ul></li><li>函数指针是指向函数的指针变量，指针函数是返回值为指针的函数</li><li>不要滥用指针，否则会出现各种糟糕的情况，例如：指针指向的指针指向的函数指针指向的指针函数返回了一个指针</li></ul><h2 id="结构体"><a class="anchor" href="#结构体">#</a> 结构体</h2><ul><li>C 语言中结构体不允许定义函数成员，且没有访问控制属性的概念。<br>C++ 为 C 语言中的结构体引入了成员函数、访问控制权限、继承、包含多态等面向对象特性。</li><li>结构体与类的区别只有一个：结构体中成员的默认保护级别为公开（public），而类中成员默认保护级别为私有（private）</li><li>C++ 之所以要引入结构体，是为了保持和 C 程序的兼容性</li><li>C 语言中，空结构体的大小为 0，而 C++ 中空结构体（属于空类）的大小为 1<ul><li>C++ 中空类的大小为 1 的原因：<br>空类也可以实例化，类实例化出的每个对象都需要有不同的内存地址，为使每个对象在内存中的地址不同，所以在类中会加入一个隐含的字节。</li></ul></li></ul><h2 id="内存分区"><a class="anchor" href="#内存分区">#</a> 内存分区</h2><p>代码区、全局 / 静态区、常量区、栈区、堆区<br>严格来说 常量不属于全局区，而是单独划分为常量区，只不过一些教材会简化处理，把它们也算进全局区</p><ul><li>代码区<br>存放函数体的二进制代码，由操作系统进行管理</li><li>全局 / 静态区<br>存放全局变量和静态变量<br>存放：全局变量、静态变量（无论是否 const，但不包括字符串常量）<br>数据段：<br>已初始化数据段 .data<br>未初始化数据段 .bss</li><li>常量区<br>字符串常量、const 全局常量（通常编译器放在只读段）<br>数据段：只读数据段 .rodata</li><li>栈区<br>由编辑器自动分配释放，存放函数的参数值和局部变量等<br>不要返回局部变量的地址</li><li>堆区<br>由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收<br>用 new（或 malloc 等动态分配函数）创造的一定在堆区，返回的是变量在堆中的地址</li><li>虚拟内存区域分布<ul><li>地址由低到高：代码区 → 常量区 (.rodata) → 全局区 (.data/.bss) → 堆 → 栈</li><li>代码区、常量区、全局区地址邻近</li><li>堆 在中间，从低地址往上长</li><li>栈 在高地址，从高地址往下长</li></ul></li></ul><h2 id="引用"><a class="anchor" href="#引用">#</a> 引用</h2><ul><li>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字<br>一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量</li><li>引用很容易与指针混淆，它们之间有三个主要的不同：<ol><li>不存在空引用，引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象，而指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化，指针可以在任何时间被初始化。</li></ol></li><li>不要返回局部变量的引用<br>函数的调用可以作为左值，对返回值进行操作</li><li>引用的本质是指针常量。 <code>int&amp; ref</code> 在内部会自动转换为 <code>int* const ref</code></li><li>常量引用：用来修饰形参，防止误操作 (可以防止引用指向的值被修改)</li></ul><h2 id="高级函数"><a class="anchor" href="#高级函数">#</a> 高级函数</h2><ul><li>函数的默认参数<br>形参可以有默认值，从第一个有默认值的形参开始，从左往右，必须全都有默认值<br>如果函数声明有默认参数，那么函数实现就不能有默认参数<br>函数声明和函数实现中只能有一个默认值</li><li>函数占位参数<br>保留位置（兼容以后扩展）<br>区分函数重载<br>占位参数可以有默认参数，例： <code>void func(int a, int, int = 10)</code><br>运算符重载时的特殊标记，例：<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Counter</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 前置 ++ (无参数)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    Counter<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token operator">++</span>value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 后置 ++ (int 占位参数区分)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    Counter <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        Counter temp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 保存当前值</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        value<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span> <span class="token comment">// 返回修改前的值</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li>函数重载：不同条件下解决同一类问题，使函数的命名相同参数不同，调用者只记住一个函数名即可。例如：<br><code>void Test();</code><br><code>void Test(int a);</code></li></ul><h1 id="基础二"><a class="anchor" href="#基础二">#</a> 基础二</h1><p>面向对象的三大特性为：封装、继承、多态</p><h2 id="类和对象封装"><a class="anchor" href="#类和对象封装">#</a> 类和对象 — 封装</h2><ul><li>封装：将属性和行为作为一个整体，并增加权限控制</li><li>类中的属性和行为统称为：成员<ul><li>属性 又称之为：成员属性、成员变量</li><li>行为 又称之为：成员函数、成员方法</li></ul></li><li>三种访问权限<ul><li>公共权限：public 成员在类的内部和外部都可以访问</li><li>保护权限：protected 成员在类的内部和继承这个类的其他类可以访问</li><li>私有权限：private 成员仅在类的内部可以访问</li></ul></li><li>设置属性的权限：<ul><li>将属性设置为 私有，然后用 方法 控制读或写的权限</li></ul></li></ul><h2 id="类和对象-对象特性"><a class="anchor" href="#类和对象-对象特性">#</a> 类和对象 - 对象特性</h2><ul><li>默认情况下 C++ 至少给类添加四个函数<ul><li>构造函数：无参数，空函数体</li><li>析构函数：无参数，空函数体</li><li>拷贝构造函数：参数为 const T&amp;，拷贝方式为浅拷贝</li><li>赋值运算符函数：operator= 参数为 const T&amp;，赋值方式为浅拷贝</li><li>如果用户定义有参构造函数，编译器不提供默认无参构造函数，但是会提供默认拷贝构造函数</li><li>如果用户定义拷贝构造函数，编译器不提供其他构造函数</li></ul></li><li>在栈中创建对象时，不能用 () 调用默认构造函数，编译器会认为是函数声明</li><li>匿名对象在栈中创建，当前行结束后立即回收<ul><li>编译器认为，匿名对象 T (s); 等同于 T s;，这可能会导致重复定义</li></ul></li><li>析构函数中必须将堆中创建的内存释放，释放后不需要将指针置空<ul><li>直接 delete 对象不会释放对象内部创建的堆内存</li><li>只需要释放堆中创建的内存，栈中的内存会自动释放</li></ul></li><li>拷贝构造函数，分为浅拷贝和深拷贝，如果不写拷贝构造函数，默认是浅拷贝<ul><li>浅拷贝会导致两个对象指向同一块内存，在析构时会重复 delete，导致程序崩溃</li><li>深拷贝复制内容，而不是复制指针</li><li>不写 const 就无法拷贝临时对象（右值）</li><li>临时对象只能绑定到 const T&amp; 或 T&amp;&amp;，不能绑定到 T</li><li>对象作为函数形参时，会调用拷贝构造函数</li><li>通过拷贝构造函数创建对象时，如果用户定义拷贝构造函数，只有手动拷贝的变量会被拷贝</li></ul></li><li>其他类的对象作为成员变量（直接在栈中的创建的对象），构造时会先构造成员变量，析构顺序与构造顺序相反</li><li>静态成员变量<ul><li>所有的对象共享同一份数据</li><li>在编译阶段分配内存</li><li>在类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有的对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li><li>静态成员函数没有 this 指针</li></ul></li><li>成员变量 和 成员函数 分开储存<ul><li>空对象占用 1 字节内存，为了区分不同对象</li><li>只有非静态成员变量占用对象内存，其他的变量和函数都不占用对象内存</li></ul></li><li>this 指针<ul><li>成员函数隐含的参数，指向调用该成员函数的对象</li><li>this 指针的本质是指针常量，不可修改 T* const this</li><li>解决名称冲突</li><li>返回对象本身</li></ul></li><li>所有非静态成员变量在使用时默认添加 this 指针<ul><li>调用 a 实际上是 this-&gt;a</li></ul></li><li>常函数<ul><li>const 修饰的是 this 指针，使 this 指针指向的值不可修改 const T* const this</li><li>const 对象仅能调用 const 函数</li></ul></li><li>mutable 修饰可变成员变量，在常函数中也可以修改</li><li>常对象<ul><li>常对象只能调用常函数</li><li>常对象不可修改成员变量</li><li>可变成员变量在常函数中可以修改</li></ul></li></ul><h2 id="类和对象-友元"><a class="anchor" href="#类和对象-友元">#</a> 类和对象 - 友元</h2><ul><li>友元可以访问私有成员<ul><li>友元类的所有成员函数都可以访问私有成员</li></ul></li><li>在声明友元的同时也实现了函数的声明（引入声明）</li></ul><h2 id="运算符重载"><a class="anchor" href="#运算符重载">#</a> 运算符重载</h2><ul><li>内置数据类型的运算符不能被重载<ul><li>不要滥用运算符重载</li></ul></li><li>成员函数 重载 + 本质上是 p1.operator+(p2)<br>全局函数 重载 + 本质上是 operator+(p1, p2)</li><li>运算符重载也可以发生函数重载</li><li>无法用成员函数 重载 &lt;&lt; 的方法实现 cout &lt;&lt; p;（p 是某个类的对象）</li><li>重载 ++ 需要 int 占位参数区分<ul><li>无占位参数是 前置 ++</li><li>有占位参数是 后置 ++</li><li>这是系统规定的</li></ul></li><li>重载 赋值运算符 =<ul><li>默认的赋值运算符是浅拷贝，所有变量全部赋值</li><li>重载的目的之一就是将它改为深拷贝</li><li>仅对有需要的变量实现赋值逻辑，其他变量不会改变</li></ul></li><li>重载 函数调用运算符 ()<ul><li>将对象当作函数使用</li><li>使用方法非常像函数调用，所以称为 仿函数</li></ul></li></ul><h2 id="类和对象-继承"><a class="anchor" href="#类和对象-继承">#</a> 类和对象 - 继承</h2><ul><li>父类中成员的权限是它能达到的最高权限<ul><li>继承方式决定了父类成员在子类中的权限，但是无法超过父类中成员本身的权限</li></ul></li><li>子类的大小 ≈ 父类的大小（所有非静态成员） + 子类新增成员的大小<ul><li>检测方法 1：<ul><li>打开 开发人员命令提示符，进入项目目录，运行 <code>cl /d1 reportSingleClassLayout&lt;类名&gt; &quot;源文件名.cpp&quot;</code></li><li>例如: <code>cl /d1 reportSingleClassLayoutHusky &quot;A4 Inheritance.cpp&quot;</code></li></ul></li><li>检测方法 2：鼠标移动到类名上，点击内存布局</li><li>一个类的大小不仅仅是 父类大小 + 子类新增成员大小，还要考虑编译器的 内存对齐<ul><li>x86 默认最大对齐是 4 字节</li><li>x64 下很多成员（尤其是指针、long long、double 等）需要 8 字节对齐</li><li>一个类的大小必须是其 最大对齐单位的整数倍</li></ul></li></ul></li><li>如果存在同名成员（包括静态成员），父类的成员会被隐藏<br>如果存在同名函数（包括静态函数），父类中所有的同名函数都会被隐藏<br>解决方法：使用 作用域限定符 来访问被隐藏的成员或函数</li><li>构造顺序：父类构造 -&gt; 子类构造<br>析构顺序：子类析构 -&gt; 父类析构</li><li>多继承<ul><li>如果多个父类中存在同名成员或函数，子类必须使用 作用域限定符 来访问</li><li>如果多个父类中存在同名的虚函数，子类重写时不需要使用 作用域限定符</li><li>实际开发中尽量避免多继承</li></ul></li><li>菱形继承<ul><li>父类（A） -&gt; 两个子类（B、C） -&gt; 一个类继承这两个子类（D）<ul><li>B、C 中相同的成员在 D 中会出现二义性</li><li>D 中有两份 A 的成员</li></ul></li><li>使用虚继承可以解决菱形继承的问题<ul><li>将 B、C 改为虚继承</li><li>在 D 的内存布局中，继承的不是 A 的数据，而是 vbptr 指针</li></ul></li><li>vbptr 表示 虚基类表指针（virtual base class pointer） 指向 vbtable（虚基类表）<ul><li>vbtable 记录了 虚基类（A） 在 菱形继承 最底层类（D）中的 偏移位置</li><li>而 A 的数据只会在 D 中存在一份</li></ul></li><li>vbtable 储存在常量区</li></ul></li></ul><h2 id="类和对象-多态"><a class="anchor" href="#类和对象-多态">#</a> 类和对象 - 多态</h2><ul><li>静态多态：函数重载、运算符重载<br>动态多态：派生类、虚函数</li><li>抽象类<ul><li>包含纯虚函数的类是 抽象类</li><li>子类继承抽象类后，必须重写所有纯虚函数，否则子类也是抽象类</li><li>抽象类通常需要一个虚析构函数，这样可以确保在通过基类指针删除派生类对象时能够正确调用派生类的析构函数</li><li>通过 抽象类 或 Concept 来实现接口</li><li>__interface 是 MSVC 的专用语法，本质上就是一个 只允许纯虚函数的抽象类，不能跨平台，不建议使用</li></ul></li><li>虚析构函数 和 纯虚析构函数<ul><li>纯虚析构函数必须有函数体，类内声明，类外初始化</li><li>父类指针 / 引用指向子类对象，删除时不会调用子类的析构函数<br>解决方法：将父类的析构函数改为虚析构函数或纯虚析构函数</li></ul></li><li>如果父类有虚函数，父类和子类的内存布局中会有 vfptr 指针<ul><li>子类中的指针是继承过来的，不是额外增加的</li><li>单继承：子类的 vfptr 覆盖并继承了父类的那个位置，内存里只有一个</li><li>多重继承或虚继承：子类会出现多个 vfptr（每个继承分支有自己的虚表）</li><li>vfptr 表示 虚函数指针（virtual function pointer） 指向 vftable（虚函数表）</li><li>vftable 记录的内容：<ol><li>指向 RTTI（运行时类型信息）结构 的指针</li><li>偏移量（从当前子对象到最顶层基类的偏移）<br>对于单继承的简单类，它可能就是 0<br>如果是复杂继承（多重继承、虚拟继承），这个值会变成一个非零偏移，用来帮编译器在调用时调整 this 指针</li><li>虚函数的函数地址</li></ol></li><li>vftable 储存在常量区</li><li>父类指针或引用指向子类对象并调用虚函数时，因为对象是子类的，所以找到的是子类的 vfptr，然后找到子类的 vftable，最后执行子类的虚函数<br>流程：父类指针 / 引用 -&gt; 子类对象 -&gt; 子类 vfptr -&gt; 子类 vftable -&gt; 子类虚函数</li></ul></li></ul><h2 id="文件操作"><a class="anchor" href="#文件操作">#</a> 文件操作</h2><ul><li>文件打开方式<br><code>ios::in</code> 只读<br><code>ios::out</code> 只写<br><code>ios::ate</code> 初始位置为文件尾<br><code>ios::app</code> 追加写入<br><code>ios::trunc</code> 如果存在先删除，再创建<br><code>ios::binary</code> 二进制</li><li>EOF 表示文件尾</li><li>不要将整个对象写入文件（或从文件读取到对象），应当手动操作每个成员变量的读写</li></ul><h2 id="命名空间"><a class="anchor" href="#命名空间">#</a> 命名空间</h2><ul><li>命名空间处在相同文件时，先创建后声明</li><li>命名空间处在不同文件时，用头文件声明<ul><li>非静态变量：<ul><li>具有 外部链接（external linkage）</li><li>可以被其他 .cpp 文件通过 extern 声明访问</li><li>所有文件共享一份</li></ul></li><li>静态变量和静态函数：<ul><li>具有 内部链接（internal linkage）</li><li>只在 定义它的那个 .cpp 文件里可见，不能 extern</li><li>每个文件独享一份，外部不可见</li><li>其他文件想要访问，只能依靠访问接口（写一个函数或方法，在内部进行操作，对外提供接口）</li></ul></li></ul></li></ul><h1 id="基础三"><a class="anchor" href="#基础三">#</a> 基础三</h1><h2 id="模版"><a class="anchor" href="#模版">#</a> 模版</h2><p>学习模版不是为了写模版，而是为了在 STL 中运用系统提供的模版。</p><ul><li>C++ 模版分为函数模版和类模版</li><li>template &lt;typename T&gt; 和 template &lt;class T&gt;<br>typename 和 class 完全等价。一开始只有 class，为了语义更清晰，引入了 typename<br>建议使用 typename</li><li>多个泛型参数参与运算时，必须保证类型一致<br>模版必须得到具体的数据类型才能使用，即使没有用到某个参数，也必须提供类型</li><li>隐式类型转换<ul><li>普通函数可以发生隐式类型转换</li><li>函数模版 自动类型推导时，不可以发生隐式类型转换</li><li>函数模版 显示指定类型时，可以发生隐式类型转换</li><li>建议使用显示指定类型的方式调用函数模版</li><li>特别情况，不论是函数模版还是普通函数，如果形参是引用，那么实参类型必须完全匹配，不能隐式转换</li></ul></li><li>调用规则<br>普通函数与函数模版都可以实现时，优先调用普通函数<br>如果函数模版有更好的匹配，则调用函数模版<br>通过空模版参数列表可以强制调用函数模版<br>函数模版可以重载</li><li>模版的局限性<br>泛型比大小传入自定义类型、泛型数组赋值等无法实现<br>通过模版具体化，可以解决自定义类型的通用化</li><li>函数模版与类模版的区别<ul><li>类模版不能自动类型推导</li><li>类模版的模版参数列表可以设置默认参数，有默认参数的情况下，创建对象时可以写空模版参数列表</li></ul></li><li>普通类中的成员函数一开始就会创建<br>类模版中的成员函数在调用时才会创建<br>分文件编写类模版时，会遇到链接错误<ul><li>方法一：包含 .cpp 文件，而不是仅包含 .h 文件</li><li>方法二（常用）：将声明和实现都写在 .hpp 文件中</li><li>约定俗成：一般来说 .hpp 文件表示模版文件</li></ul></li><li>类模版对象做函数参数<ul><li>指定传入类型（常用）</li><li>参数模版化</li><li>类模版化</li></ul></li><li>子类继承类模版时，必须指定参数类型或将子类也变成类模板</li></ul><h2 id="stl"><a class="anchor" href="#stl">#</a> STL</h2><ul><li>标准模板库 STL（Standard Template Library）<br>几乎所有的 STL 组件都是用模版实现的<br>广义上分为：容器、算法、迭代器，容器和算法通过迭代器连接<br>细分为六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器<br>容器：存放数据 vector、list、deque、set、map<br>算法：操作数据 sort、find、copy、for_each<br>迭代器：连接容器和算法，类似指针<br>仿函数：可以像函数一样调用的对象，可作为算法的某种策略<br>适配器：对容器或迭代器进行改造 stack、queue、priority_queue<br>空间配置器：分配内存</li><li>容器将运用广泛的数据结构实现出来<br>分为 序列式容器 和 关联式容器<br>序列式容器：按照元素插入的顺序来存储数据<br>关联式容器：自动排序并组织数据，底层一般基于平衡二叉搜索树（红黑树）实现</li><li>算法用于解决逻辑或数学问题<br>分为 质变算法 和 非质变算法<br>质变算法：运算过程中会修改容器中的元素<br>非质变算法：运算过程中不会修改容器中的元素</li><li>迭代器是连接容器和算法的桥梁<br>迭代器类似于指针，可以遍历容器中的元素<br>迭代器是概念上对指针行为的抽象，但不一定由指针实现<br>迭代器分为五种类型：输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器<br>不同的容器支持不同类型的迭代器</li><li>仿函数是可以像函数一样调用的对象<br>仿函数本质上是一个类，重载了 () 运算符<br>仿函数可以有自己的状态<br>仿函数可以作为算法的某种策略</li><li>适配器是对容器或迭代器进行改造<br>容器适配器：stack、queue、priority_queue<br>迭代器适配器：insert_iterator、reverse_iterator、stream_iterator</li><li>空间配置器负责内存分配<br>STL 默认的空间配置器是 std::allocator<br>可以自定义空间配置器以满足特殊需求</li><li>string 容器是 char* 的封装类</li><li>vector 和数组很相似，也称为单端数组<br>头部插入和删除效率低，访问元素效率高<br>容量超上限时，会创建一个新的更大的空间，拷贝原数据，删除原空间<br>插入和删除操作可能会使原有迭代器失效</li><li>deque 是双端数组<br>支持在头尾高效插入和删除，访问元素效率较低<br>deque 内部使用中控器管理多个缓冲区，中控器中存放缓冲区的地址<br>deque 的迭代器支持随机访问</li><li>const_iterator 是只读迭代器<br>用于遍历 const 容器，不能修改容器中的元素</li><li>所有支持随机访问的容器，都可以用 sort 排序</li><li>list 容器是双向链表<br>支持在任意位置高效插入和删除，不支持随机访问，访问元素效率低<br>链表由节点组成，每个节点包含数据和指向前后节点的指针<br>list 支持双向迭代器<br>插入和删除操作不会使原有迭代器失效<br>list 有自己独特的排序方法 sort<br>forward_list 是单向链表<br>与 CSharp 做对比：CSharp 中的 List&lt;T&gt; 是一个基于数组实现的动态顺序表，类似于 C++ 中的 vector，而 LinkedList&lt;T&gt; 是一个双向链表</li><li>不支持随机访问的迭代器不能用标准算法，他们的内部会提供算法</li><li>set/multiset 容器是关联式容器<br>自动排序并组织数据<br>set 不允许有重复元素，multiset 允许有重复元素<br>元素是常量，不能修改（不能通过迭代器或引用直接修改 set 中元素的值）<br>支持双向迭代器，不支持随机访问</li><li>map/multimap 容器是关联式容器<br>所有元素都是 pair 键值对<br>按 key 值自动排序并组织数据<br>map 不允许有重复 key，multimap 允许有重复 key<br>key 不能修改，value 可以修改<br>支持双向迭代器，不支持随机访问<br>使用 map [key] 时需要注意：如果 key 输入错误，内部会自动创建一个键值对</li><li>重载 () 操作符的类，称为函数对象，也称为仿函数<br>可以像函数一样调用，但本质上是一个类<br>函数对象可以作为参数<br>返回 bool 的仿函数称为谓词，根据参数的数量分为一元谓词和二元谓词</li><li>内置函数对象<br>算术仿函数：加、减、乘、除、取模、取反<br>关系仿函数：等于、不等于、大于、大于等于、小于、小于等于<br>逻辑仿函数：与、或、非</li><li>算法头文件<br>algorithm 最常用，包含大部分算法<br>numeric 包含小部分算法</li><li>find 算法搜索自定义数据类型时，类需要重载 == 运算符（const 参数）</li><li>随机种子<br>不设置随机种子会导致每次随机的结果都相同<br>用时间作为随机种子 srand ((unsigned int) time (nullptr));</li><li>注意部分算法要求有序元素</li></ul><h2 id="lambda-表达式"><a class="anchor" href="#lambda-表达式">#</a> lambda 表达式</h2><ul><li>结构 <code>[捕获列表](参数) &#123; 函数体 &#125;</code></li><li>捕获列表<br>[] 不捕获任何外部变量。Lambda 只能使用自己参数里的东西，比如 (int a)<br>[=] 以值捕获所有在外层作用域中可见的变量。就是复制一份进来，函数体里能读不能改<br>[&amp;] 以引用捕获所有外层变量。可以修改外层变量<br>[x] 只以值捕获变量 x<br>[&amp;x] 只以引用捕获变量 x<br>[&amp;, x] 混合捕获。默认引用捕获，但 x 例外用值捕获</li></ul><div class="tags"><a href="/tags/CPP/" rel="tag"><i class="ic i-tag"></i> CPP</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-12-24 08:33:41" itemprop="dateModified" datetime="2025-12-24T08:33:41+08:00">2025-12-24</time> </span><span id="2025/11/11/CPP/CPPBasics/CPP基础笔记/" class="item leancloud_visitors" data-flag-title="CPP 基础笔记" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Maikire 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Maikire 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Maikire 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Maikire <i class="ic i-at"><em>@</em></i>forget-me-not</li><li class="link"><strong>本文链接：</strong> <a href="https://maikire.xyz/2025/11/11/CPP/CPPBasics/CPP%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="CPP 基础笔记">https://maikire.xyz/2025/11/11/CPP/CPPBasics/CPP基础笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2025/08/20/Unity/UnityFramework/%E8%A1%8C%E4%B8%BA%E6%A0%91/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.z4a.net&#x2F;images&#x2F;2025&#x2F;08&#x2F;01&#x2F;null-3850ac89830f01c2.jpeg" title="行为树"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UnityFramework</span><h3>行为树</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">基础一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.1.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">内存分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">高级函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BA%8C"><span class="toc-number">2.</span> <span class="toc-text">基础二</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">类和对象 — 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">类和对象 - 对象特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%8F%8B%E5%85%83"><span class="toc-number">2.3.</span> <span class="toc-text">类和对象 - 友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.</span> <span class="toc-text">类和对象 - 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81"><span class="toc-number">2.6.</span> <span class="toc-text">类和对象 - 多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.</span> <span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">2.8.</span> <span class="toc-text">命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%B8%89"><span class="toc-number">3.</span> <span class="toc-text">基础三</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%89%88"><span class="toc-number">3.1.</span> <span class="toc-text">模版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl"><span class="toc-number">3.2.</span> <span class="toc-text">STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">lambda 表达式</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2025/11/11/CPP/CPPBasics/CPP%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" rel="bookmark" title="CPP基础笔记">CPP基础笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Maikire" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Maikire</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">75</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">21</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21haWtpcmU=" title="https:&#x2F;&#x2F;github.com&#x2F;maikire"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQyNTE2MzE4MA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;425163180"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzgxNDY5ODQ5P3NwbV9pZF9mcm9tPTMzMy4xMDA3LjAuMA==" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;381469849?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmwyNTQxNzU4OTg5QGdtYWlsLmNvbQ==" title="mailto:l2541758989@gmail.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/games" rel="section"><i class="ic i-play"></i>游戏</a></li><li class="item"><a href="/friends" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cudHJhdmVsbGluZ3MuY24vZ28uaHRtbA=="><i class="ic i-paper-plane"></i>开往</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Unity/" title="分类于 Unity">Unity</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity/UnityToolClass/" title="分类于 UnityToolClass">UnityToolClass</a></div><span><a href="/2023/06/12/Unity/UnityToolClass/%E7%BA%BF%E7%A8%8B%E4%BA%A4%E5%8F%89%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/" title="线程交叉访问助手">线程交叉访问助手</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="分类于 CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharpBasics/" title="分类于 CSharpBasics">CSharpBasics</a></div><span><a href="/2023/03/28/CSharp/CSharpBasics/%E6%9E%9A%E4%B8%BE%E5%99%A8%EF%BC%88Enumerator%EF%BC%89/" title="枚举器（Enumerator）">枚举器（Enumerator）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/DesignPatterns/" title="分类于 DesignPatterns">DesignPatterns</a></div><span><a href="/2023/07/31/DesignPatterns/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="解释器模式">解释器模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity/" title="分类于 Unity">Unity</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity/UnityFramework/" title="分类于 UnityFramework">UnityFramework</a></div><span><a href="/2023/05/05/Unity/UnityFramework/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ARPG%E6%8A%80%E8%83%BD%E6%A1%86%E6%9E%B6/" title="一个简单的ARPG技能框架">一个简单的ARPG技能框架</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/" title="分类于 游戏设计">游戏设计</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1/" title="分类于 关卡设计">关卡设计</a></div><span><a href="/2024/05/10/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1/%E9%94%81%E9%92%A5%E8%AE%BE%E8%AE%A1/" title="锁钥设计">锁钥设计</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity/" title="分类于 Unity">Unity</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity/UnityToolClass/" title="分类于 UnityToolClass">UnityToolClass</a></div><span><a href="/2023/08/14/Unity/UnityToolClass/%E8%B7%AF%E5%BE%84%E5%8A%A9%E6%89%8B/" title="路径助手">路径助手</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="分类于 CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharpBasics/" title="分类于 CSharpBasics">CSharpBasics</a></div><span><a href="/2023/03/20/CSharp/CSharpBasics/CSharp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="CSharp基础笔记">CSharp基础笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/DesignPatterns/" title="分类于 DesignPatterns">DesignPatterns</a></div><span><a href="/2023/07/30/DesignPatterns/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" title="中介者模式">中介者模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/DesignPatterns/" title="分类于 DesignPatterns">DesignPatterns</a></div><span><a href="/2023/07/29/DesignPatterns/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="迭代器模式">迭代器模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/DesignPatterns/" title="分类于 DesignPatterns">DesignPatterns</a></div><span><a href="/2023/07/17/DesignPatterns/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" title="工厂方法模式">工厂方法模式</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2026</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Maikire @ Starry Letter</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span><br><span class="exturl" data-url="aHR0cHM6Ly9pY3AuZ292Lm1vZS8/a2V5d29yZD0yMDI2NzI3NA==">萌ICP备20267274号</span><br>May you, the beauty of this world, always shine.</div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/11/11/CPP/CPPBasics/CPP基础笔记/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>